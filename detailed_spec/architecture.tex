\chapter{Architecture}

\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{img/hlasm_architecture}
	\caption{The architecture of HLASM Plugin}
	\label{fig03:arch}
\end{figure}

 The architecture is based on the way modern code editors and IDEs are extended to support additional languages. We chose to implement Language Server Protocol \footnote{https://microsoft.github.io/language-server-protocol/} (LSP), which is supported by majority of contemporary editors.

In LSP the two parties who communicate are called \emph{client}  and \emph{language server}. The client runs as an extension of development tool. All language-specific user actions are transformed into standard LSP messages and sent to the language server, which analyses the source code and sends back response, which is then interpreted and presented to the user in editor-specific way. This architecture makes possible to have only one LSP client implementation for each code editor which may be reused by all programming languages. And vice versa, every language server may be easily used by any editor that has an implementation of LSP client.

To add support for HLASM we have to implement LSP language server and write thin extension to an editor, which will use already existing implementation of LSP client. 

This chapter presents decomposition of the project into smaller components and describes their relations. The overall architecture is pictured in Figure~\ref{fig03:arch}.

\section{Language server}

The responsibility of the Language server component is to implement LSP. The features include: and pass all the calls to parser library. The issues that it addresses:

\begin{itemize}
    \item To read LSP messages from standard input or TCP and write responses.
    \item To parse JSON RPC to C++ structures so they can be further used.
    \item To serialize C++ structures into JSON, so it can be sent back to client.
    \item Implement asynchronous request handling. For example when user makes several consecutive changes to a source code, it is not needed to parse every change, only the final version.
\end{itemize}

\section{Parser library}

\subsection{Workspace manager}

\subsection{Analyser}

\subsubsection{Lexer}
\subsubsection{Parser}
\subsubsection{Processing}
\subsubsection{Checking}






\subsection{Debugger}



\section{VS code client}

mirko:

a je fajn rozepsat vsechny API a takovy veci co sou po ceste

--velky graf vsetkych komponent
--ku kazdemu odstavcek 